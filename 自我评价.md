# Week 1 课程日志：初识数据库
## ​​主要认知：​​
这节课让我对于“数据”有了新的认知——它不仅是数字和记录，更是推动决策甚至定义“真实”的基础（老师引用的结绳记事到元宇宙的跨度很震撼）。

## ​​关键知识点：​​

​​DBMS是什么？​​ 统一了理解：不仅是数据集合（百度/Oracle），更是管理系统（DBMS定义），核心目标是提供 ​​Convenient (方便)​​ 和 ​​Efficient (高效)​​ 的数据访问。
​​为何需要数据库？​​ 文件系统管理数据（如教务.txt例子）的弊端太明显：​​冗余、不一致、隔离、难访问、完整性难保证、安全性弱、并发问题、原子性问题​​。对比之下，DBMS的优势不言而喻。
​​数据抽象三层结构：​​ 物理层（存储细节）、逻辑层（数据结构与关系）、视图层（用户视角）。​​物理数据独立性​​ 是核心优势，开发者隐藏复杂性，用户/应用无需关心底层变动。
​​数据库语言：​​ ​​DDL​​ 定义结构（如建表），​​DML​​ 操作数据（如查询、更新）。SQL 是主流，其 ​​声明式（What，而非How）​​ 特性很吸引人。

## ​​小插曲与任务：​​

安装 PostgreSQL 和 DataGrip 是本周动手任务。PG 安装还算顺利（选对平台安装包很重要），DataGrip 初次配置界面略复杂。
老师留的思考题：“关系”数据库的“关系”本质是什么？目前理解是数据间基于二维表的关联映射（但总觉得这解释太浅层，需深究）。

# Week 2 课程日志：关系模型
## ​​关键知识点：​​
本周系统化学习关系模型的三层架构：

**· 二维表本质**：
关系（Relation）= 表（Table），属性（Attribute）= 列（Header），元组（Tuple）= 行（数据记录）  
通过教务系统 instructor 表实例拆解：`ID|name|dept_name|salary` 是模式，每条记录是元组

**· 键约束体系**：
- 超码（Super Key）：`(ID, name)` 可唯一标识，但存在冗余
- 候选码（Candidate Key）：最小超码（如纯 `ID`）
- 主码（Primary Key）：设计选定的候选码（`ID` 作主键）
- 外码（Foreign Key）：`instructor.dept_name` 引用 `department.dept_name`，建立表间逻辑关联

**· 关系代数基础**：
- 选择（σ）：`σ_{salary>90000}(instructor)` → 筛选高薪教师
- 投影（Π）：`Π_{name,dept_name}(instructor)` → 提取姓名与学院
- 笛卡尔积（×）→ 自然连接（⋈）：理解 `instructor ⋈ teaches` 如何关联教师与授课
​​
## 实践：​​

用关系代数解答习题：
``` 
/* 找出上海员工 */  
Π_{person\_name}(σ_{city="上海"}(employee))  
/* 高薪员工 */  
Π_{person\_name}(σ_{salary>10000}(employee ⋈ works))
```
​​自然连接 vs θ连接​​：通过instructor和teaches案例理解自动匹配同名属性与自定义条件的区别
## ​​思考：​​

主码选择不仅是技术决策（如classroom表用(building, room_number)复合主键），更是业务逻辑的体现

## 总结：​​
从二维表结构到键约束体系，再到关系代数运算，逐步构建数据库的数学模型。本周最大收获是理解​​主外键如何将离散表编织为有机整体​​——这种逻辑关联正是“关系”二字的精髓。期待下周通过SQL将理论转化为实操。


# Week 3 课程日志：SQL入门实战
## ​​关键知识点​​
SQL作为关系型数据库标准语言的发展脉络（1986标准化 → 2023最新标准）
"SQL方言"现象：PostgreSQL/MySQL/SQL Server在标准基础上各有扩展
​​- 数据类型精度控制​​：
```
CREATE TABLE weather (  
  city    VARCHAR(80) PRIMARY KEY,  
  temp_lo INT CHECK (temp_lo BETWEEN -50 AND 50),  -- 温度约束  
  date    DATE NOT NULL  
);
```
​​- 外键级联操作​​：
```
FOREIGN KEY (dept_name) REFERENCES department  
ON DELETE SET NULL  -- 学院删除时教师部门置空  
​​DML查询三要素​​
SELECT name, salary/12 AS monthly_sal  -- 投影+计算  
FROM instructor  
WHERE dept_name = 'Physics'   -- 选择条件  
  AND salary BETWEEN 90000 AND 100000;  -- 范围查询
``` 
## ​​ 实践​​
​​- 多表连接陷阱​​：
```
/* 错误：缺失连接条件导致笛卡尔积 */  
SELECT name, building  
FROM instructor, department;  -- 返回12×7=84条冗余数据  

/* 修正：显式指定连接条件 */  
SELECT name, building  
FROM instructor  
JOIN department ON instructor.dept_name = department.dept_name;
```
- ​​NULL的玄机​​：
```
SELECT * FROM weather  
WHERE prcp IS NULL;  -- 必须用IS NULL判断空值
```
## ​​​​思考​​
​​DDL设计​​：
VARCHAR(80)比TEXT更体现业务约束（如城市名长度）
复合主键(city, date)能唯一标识每日天气记录
​​SQL声明式本质​​：
SELECT name FROM instructor WHERE salary > 90000;  
只需声明"找高薪教师"，无需关心DBMS如何扫描索引或优化执行
​​
## ​​总结​​
从DDL的精确类型定义到DML的声明式查询，SQL将关系模型转化为可执行语言。本周最大收获是​​通过连接条件规避笛卡尔积陷阱​​——多表查询时漏写ON堪比编程界的"未初始化变量"。

# Week 4 课程日志：SQL实验课实战
## ​​​​关键知识点
- ​​环境搭建​​：
成功部署PostgreSQL（Mac：createdb mydb / Win：CREATE DATABASE mydb;）
DataGrip连接配置突破：解决驱动缺失→下载→测试连接成功（关键参数：user=postgres, db=mydb）
- ​​数据集初始化​​：
-- 执行顺序：
```
1.DDL.sql → 2.smallRelationsInsertFile.sql  
CREATE TABLE instructor(ID VARCHAR(5) PRIMARY KEY, ...);  -- 建立9张教学关系表  
INSERT INTO instructor VALUES ('10101','Srinivasan','Comp.Sci.',65000); -- 注入测试数据  
​​数据验证​​：SELECT COUNT(*) FROM instructor; → 返回12条教师记录
``` 
## SQL实践​​：
​​- 字符串陷阱​​：
```
SELECT 'I''m good' AS escaped_text;  -- 单引号转义：双写''  
SELECT * FROM users WHERE name LIKE 'ab\\%d%'; -- 匹配"ab%开头"（转义反斜杠）
```
​​- 模糊查询实战​​：
-- 匹配'Wu'开头教师（注意_和%区别）  
```
SELECT * FROM instructor WHERE name LIKE 'Wu%';  -- Wu及更长（如"Wu"）  
SELECT * FROM instructor WHERE name LIKE 'Wu_';  -- 严格三字符（如"Wu "）  
```

## ​​方言兼容性实验​​：
| 操作         | PostgreSQL               | MySQL                     |
|--------------|--------------------------|---------------------------|
| 字符串拼接   | `name \|\| dept_name`    | `CONCAT(name, dept_name)` |
| 分页         | `LIMIT 10`               | `LIMIT 10 OFFSET 0`       |
| 大小写敏感   | `'china'='CHINA' → f`    | `'china'='CHINA' → t`     |

- ​​集合操作缺陷警示​​：
``` 
/* MySQL不支持INTERSECT/EXCEPT！需用JOIN改写 */  
(SELECT course_id FROM section WHERE semester='Fall')  
INTERSECT  -- 在MySQL中报错  
(SELECT course_id FROM section WHERE semester='Spring');
```
## ​​思考​​
- ​​LIKE的通配符代价​​：
%开头的模糊查询（如%sic）无法利用索引 → 全表扫描性能风险
解决方案：​​前置分词+倒排索引​​（后续课程待研究）

- ​​NULL的三态逻辑​​：
```
SELECT * FROM weather  
WHERE prcp IS NULL;  -- 必须显式用IS NULL  
任何prcp = NULL的比较都返回​​unknown​​而非false → 易引发查询遗漏
```

## 总结​​
从环境搭建到方言适配，本周是SQL从理论迈向实战的关键一步。最大收获是​​理解模糊查询的索引陷阱​​与​​NULL的三态逻辑本质​​。实验中多次因MySQL、PostgreSQL集合操作不兼容而重构查询，深刻体会到"纸上得来终觉浅"。

# Week 5 课程日志：空值与聚合查询深度探索
## ​​关键知识点：
- ​​NULL的三态逻辑​​：
-- 实验验证布尔运算：
```
SELECT TRUE AND NULL;  -- → NULL  
SELECT FALSE OR NULL; -- → NULL  
SELECT NOT NULL;       -- → NULL
```

​​- 关键：比较salary > 80000时，若salary为NULL→结果UNKNOWN→元组被过滤

​​- 聚合函数NULL处理​​：
-- COUNT(*)计数包含NULL行，COUNT(列)忽略NULL  
```
SELECT COUNT(*) total_rows, COUNT(salary) non_null_salaries FROM instructor;
```
-- 特殊场景：AVG(salary)自动忽略NULL值计算

​​- 分组统计与HAVING​​：
-- 统计各系平均工资>42,000的系 
```
SELECT dept_name, AVG(salary) avg_sal  
FROM instructor  
GROUP BY dept_name  
HAVING AVG(salary) > 42000;  -- HAVING在分组后过滤
``` 
​​执行顺序警示​​：
```
A[FROM] --> B[WHERE] --> C[GROUP BY] --> D[HAVING] --> E[SELECT]  
```

## ​​嵌套子查询实战​​：
```
/* 找出2017秋开课且2018春也开课的课程 */  
SELECT course_id  
FROM section  
WHERE semester='Fall' AND year=2017  
  AND course_id IN (  -- 替代INTERSECT确保MySQL兼容  
    SELECT course_id  
    FROM section  
    WHERE semester='Spring' AND year=2018  
  );
```

## ​​​​思考​​
- ​​集合比较的语义转化​​：
自然语言	SQL等价式
"比某些历史系教师工资高"	salary > SOME(SELECT salary...)
"比所有历史系教师工资高"	salary > ALL(SELECT salary...)

​​- 相关子查询性能陷阱​​：
```
SELECT dept_name, (  
  SELECT COUNT(*)  
  FROM instructor i  
  WHERE i.dept_name = d.dept_name  -- 外层关联导致Nested Loop  
) teacher_count  
FROM department d;
```
​​--优化方向​​：改用LEFT JOIN+GROUP BY
​​
- ​​WITH子句的递归潜力​​：
```
WITH RecursiveOrg AS (  
  SELECT id, manager_id FROM employees WHERE id=101  
  UNION ALL  
  SELECT e.id, e.manager_id  
  FROM employees e  
  JOIN RecursiveOrg r ON e.manager_id = r.id  
)  
SELECT * FROM RecursiveOrg;  -- 是否支持组织层级递归？  
​​```

## 总结​​
本周深刻体会到​​NULL的破坏性​​——不仅影响比较运算，更颠覆聚合逻辑。HAVING子句与GROUP BY的配合解锁了维度分析能力，但相关子查询的性能隐患警示着「优雅≠高效」。最大收获是掌握> SOME/ALL的集合思维，将自然语言转化为精准查询。



# Week 6 课程日志：SQL数据操作与约束深化
​​核心进展​​
​​数据操作命令突破​​：
​​删除的语义区分​​：
DELETE FROM instructor WHERE ID='8888';  -- 删数据  
DROP TABLE instructor;                   -- 删表结构  
​​批量插入优化​​：PG的COPY命令比INSERT快100倍（实测万级数据秒级导入）
​​智能更新​​：
UPDATE instructor  
SET salary = CASE  
    WHEN salary <= 100000 THEN salary * 1.05  
    ELSE salary * 1.03  
END;  -- 单语句实现差异化调薪  
​​DDL约束体系强化​​：
约束类型	关键特性	示例
UNIQUE	允许多个NULL值（不同于主键）	product_no INTEGER UNIQUE
CHECK	验证失败时阻止操作	price NUMERIC CHECK (price > 0)
级联外键	自动处理关联数据	ON DELETE CASCADE
​​排名函数实战​​：
-- 解决“并列第一”问题  
SELECT id, name,  
  RANK() OVER (ORDER BY salary DESC NULLS LAST) AS salary_rank  
FROM instructor;  
​​警示​​：WHERE salary_rank=1非法 → 必须嵌套子查询
​​关键实践​​
​​外键级联实验​​：
ALTER TABLE section  
ADD CONSTRAINT fk_course  
FOREIGN KEY (course_id) REFERENCES course  
ON DELETE CASCADE;  -- 删除课程时自动删除相关章节  
测试：删除course_id='CS-101' → 关联的3条section记录同步消失
​​唯一约束陷阱​​：
INSERT INTO products (product_no) VALUES (NULL), (NULL); -- 成功！  
结论：UNIQUE约束中​​NULL不等于NULL​​ → 允许多个NULL存在
​​深度反思​​
​​CHECK约束的边界​​：
CREATE TABLE employee (  
  age INT CHECK (age >= 18)  -- 插入NULL能成功！  
);  
​​根本原因​​：CHECK只拒绝false，unknown（NULL导致）被视为满足
​​解决方案​​：NOT NULL+CHECK组合约束
​​排名函数执行逻辑​​：
graph TB  
A[数据扫描] --> B[窗口排序] --> C[RANK计算] --> D[结果输出]  




性能关键：排序阶段内存消耗（大数据需work_mem调优）
​​待解困惑​​
​​级联删除的递归深度​​：
若course→section→exam多级外键链，ON DELETE CASCADE是否会递归删除？
PG文档提示：最大深度64层 → 如何预防无限循环？
​​条件更新的原子性​​：
UPDATE account  
SET balance = balance - 100   -- 转出  
WHERE id = 'A';  
  
UPDATE account  
SET balance = balance + 100   -- 转入  
WHERE id = 'B';  
​​问题​​：中间故障是否导致数据不一致？ → 需事务机制介入
​​总结​​
本周打通SQL“增删改”的操作闭环，深刻体会​​数据完整性的复杂代价​​——从UNIQUE的NULL陷阱到外键级联的隐蔽风险。最大收获是用RANK()优雅解决TopN查询，同时警醒于CHECK约束的逻辑边界。数据库的健壮性正建立在层层约束的基石之上。

